---
title: Merkle Trees
icon: tabler:tree
---

ব্লকচেইনের নিরাপত্তা, স্কেলেবিলিটি এবং ডেটা ভেরিফিকেশনের জন্য Merkle Tree একটি অপরিহার্য ডেটা স্ট্রাকচার। এটি এমন একটি গাছ, যেখানে প্রতিটি "লিফ" নোডে ডেটার হ্যাশ থাকে এবং প্রতিটি "প্যারেন্ট" নোডে তার দুইটি চাইল্ডের হ্যাশের সংমিশ্রণ থাকে।

## Merkle Tree কী?

Merkle Tree (বা Binary Hash Tree) হচ্ছে একটি ডেটা স্ট্রাকচার, যেখানে:
- প্রতিটি লিফ নোডে ডেটার হ্যাশ থাকে
- প্রতিটি প্যারেন্ট নোডে তার দুই চাইল্ডের হ্যাশ কনক্যাট করে আবার হ্যাশ করা হয়
- রুট নোডে পুরো ডেটা সেটের "Merkle Root" থাকে

## কেন Merkle Tree?

- **ডেটা ভেরিফিকেশন:** দ্রুত ও সহজে চেক করা যায় কোনো ডেটা ব্লকে পরিবর্তন হয়েছে কিনা
- **স্কেলেবিলিটি:** বড় ডেটা সেটেও দ্রুত ভেরিফিকেশন সম্ভব
- **নিরাপত্তা:** হ্যাশিং-এর মাধ্যমে ডেটা টেম্পারিং রোধ করা যায়

## বাস্তব উদাহরণ ও এনালজি

- **বইয়ের সূচিপত্র:** যেমন বইয়ের সূচিপত্র দেখে দ্রুত নির্দিষ্ট অধ্যায় খুঁজে পাওয়া যায়, Merkle Tree-তে দ্রুত নির্দিষ্ট ডেটা ব্লক যাচাই করা যায়
- **ফাইল চেকসম:** যেমন ফাইল ডাউনলোডের পরে চেকসম দিয়ে ভেরিফাই করা হয়, Merkle Root দিয়ে পুরো ব্লকচেইনের ডেটা ভেরিফাই করা যায়

## ব্লকচেইনে Merkle Tree-এর ব্যবহার

- **বিটকয়েন:** প্রতিটি ব্লকে ট্রান্সাকশনগুলো Merkle Tree-তে সাজানো হয়, এবং ব্লকের হেডারে Merkle Root সংরক্ষিত থাকে
- **Ethereum:** স্টেট, ট্রান্সাকশন, এবং রিসিপ্টের জন্য Merkle Patricia Tree ব্যবহার হয়

## কিভাবে কাজ করে?

1. প্রতিটি ট্রান্সাকশনের হ্যাশ নিন
2. দুইটি করে হ্যাশ কনক্যাট করে আবার হ্যাশ করুন
3. এইভাবে উপরে যেতে যেতে একদম শেষে Merkle Root পাবেন

## চিত্র

```
        Merkle Root
           /    \
      H12        H34
     /   \      /   \
   H1    H2   H3    H4
```

- H1, H2, H3, H4: ট্রান্সাকশনের হ্যাশ
- H12 = hash(H1 + H2)
- H34 = hash(H3 + H4)
- Merkle Root = hash(H12 + H34)

## Python কোড ডেমো: Merkle Tree তৈরি

```python
import hashlib

def hash_pair(a, b):
    return hashlib.sha256((a + b).encode()).hexdigest()

def merkle_root(leaves):
    if len(leaves) == 1:
        return leaves[0]
    new_level = []
    for i in range(0, len(leaves), 2):
        a = leaves[i]
        b = leaves[i+1] if i+1 < len(leaves) else a
        new_level.append(hash_pair(a, b))
    return merkle_root(new_level)

# উদাহরণ
leaves = [hashlib.sha256(f"tx{i}".encode()).hexdigest() for i in range(4)]
root = merkle_root(leaves)
print("Merkle Root:", root)
```

## পারফরম্যান্স ও সিকিউরিটি টিপস

- Merkle Tree ব্যবহার করলে ডেটা ভেরিফিকেশন দ্রুত হয়
- ডেটা ব্লক পরিবর্তন হলে Merkle Root বদলে যায়, তাই সহজে টেম্পারিং ধরা যায়
- বড় নেটওয়ার্কে স্কেলেবিলিটি বাড়াতে Merkle Tree অপরিহার্য

## পরবর্তী পাঠ

[ব্লকচেইন স্টোরেজ](/blockchain/storage)
