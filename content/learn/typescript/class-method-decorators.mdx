---
title: ক্লাস, প্রপার্টি ও মেথড ডেকোরেটর
icon: lineicons:typescript
---

## পরিচিতি

ধরা যাক, আপনি একটি গাড়ি বানাচ্ছেন—গাড়ির বডি, ইঞ্জিন, চাকা, আর প্রতিটি অংশে আলাদা আলাদা "অ্যাড-অন" বা ফিচার যোগ করছেন। TypeScript-এ ক্লাস, প্রপার্টি ও মেথড ডেকোরেটর ঠিক এমনই—প্রতিটি অংশে আলাদা "ম্যাজিক" যোগ করে, তাদের আচরণ ও ক্ষমতা বাড়িয়ে দেয়।

## অ্যানালজি

ডেকোরেটরকে ভাবুন "মোবাইল অ্যাপের থিম" হিসেবে—একই অ্যাপ, কিন্তু থিম বদলালে চেহারা ও ফিচার বদলে যায়। ক্লাস, প্রপার্টি ও মেথড ডেকোরেটর কোডের "থিম" ও "বিহেভিয়ার" বদলে দেয়।

## বিস্তারিত ব্যাখ্যা

### ক্লাস ডেকোরেটর
- পুরো ক্লাসকে "র‍্যাপ" করে
- সাধারণত ক্লাসের কনস্ট্রাক্টর বা প্রোটোটাইপ পরিবর্তন করে
- Logging, validation, singleton, ইত্যাদি implement করা যায়

### প্রপার্টি ডেকোরেটর
- ক্লাসের নির্দিষ্ট প্রপার্টিকে "র‍্যাপ" করে
- প্রপার্টির metadata, validation, default value ইত্যাদি সেট করা যায়

### মেথড ডেকোরেটর
- ক্লাসের নির্দিষ্ট মেথডকে "র‍্যাপ" করে
- Logging, authorization, caching, ইত্যাদি implement করা যায়

### কোড উদাহরণ

```typescript
// ক্লাস ডেকোরেটর
function Singleton<T extends { new (...args: any[]): {} }>(constructor: T) {
  return class extends constructor {
    static instance: any;
    constructor(...args: any[]) {
      if (!Singleton.instance) {
        super(...args);
        Singleton.instance = this;
      }
      return Singleton.instance;
    }
  };
}

@Singleton
class Database {
  connect() {
    console.log("Connected");
  }
}

const db1 = new Database();
const db2 = new Database();
console.log(db1 === db2); // true

// প্রপার্টি ডেকোরেটর
function Readonly(target: any, propertyKey: string) {
  Object.defineProperty(target, propertyKey, {
    writable: false,
  });
}

class User {
  @Readonly
  name = "Anis";
}

// মেথড ডেকোরেটর
function Log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const original = descriptor.value;
  descriptor.value = function (...args: any[]) {
    console.log(`Calling ${propertyKey} with`, args);
    return original.apply(this, args);
  };
}

class Calculator {
  @Log
  add(a: number, b: number) {
    return a + b;
  }
}

const calc = new Calculator();
calc.add(5, 7); // Output: Calling add with [5, 7]
```

## সুবিধা

- কোডের behavior সহজে extend/modify করা যায়
- DRY (Don't Repeat Yourself) principle বজায় রাখা যায়
- Framework/library-তে powerful API তৈরি করা যায়

## ব্যবহার

- Angular, NestJS, MobX ইত্যাদি ফ্রেমওয়ার্কে ডেকোরেটর heavily ব্যবহৃত
- Custom validation, logging, caching
- Dependency injection

## গুরুত্বপূর্ণ পয়েন্ট

- ডেকোরেটর experimental, তাই সব ব্রাউজারে/রানটাইমে সাপোর্ট নাও থাকতে পারে
- `tsconfig.json`-এ `experimentalDecorators: true` লাগবে
- ডেকোরেটর ফাংশন সাধারণত তিনটি আর্গুমেন্ট নেয়: target, propertyKey, descriptor

## অনুশীলন

1. একটি ক্লাস ডেকোরেটর লিখুন, যা ক্লাসকে singleton বানায়
2. একটি প্রপার্টি ডেকোরেটর লিখুন, যা প্রপার্টিকে readonly করে
3. একটি মেথড ডেকোরেটর লিখুন, যা মেথড কল হলে আর্গুমেন্ট ও রিটার্ন ভ্যালু লগ করে

## আরও জানুন
- [ডেকোরেটর কী ও কিভাবে কাজ করে](/typescript/decorators)
- [মেটাডাটা রিফ্লেকশন API](/typescript/reflect-metadata)
- [TypeScript-এ ক্লাস ও ইন্টারফেস](/typescript/classes)

---

ক্লাস, প্রপার্টি ও মেথড ডেকোরেটর TypeScript-এ কোডকে আরও "ম্যাজিক" ও শক্তিশালী করে তোলে, বিশেষ করে বড় ও স্কেলেবল অ্যাপ্লিকেশনে।
