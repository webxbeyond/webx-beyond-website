---
title: Domain-driven Design (DDD) সাথে TypeScript
icon: mdi:domain
---

## ভূমিকা

বড় ও জটিল সফটওয়্যার তৈরি করতে গেলে শুধু কোড লিখলেই হয় না—প্রকৃত সমস্যার গভীরে গিয়ে, সেই "ডোমেইন" বা ব্যবসার নিয়ম-কানুন বুঝে, তার ভিত্তিতে সফটওয়্যার ডিজাইন করতে হয়। Domain-driven Design (DDD) ঠিক এই কাজটাই করে। TypeScript-এ DDD ব্যবহার করলে, কোড শুধু ফিচার নয়, ব্যবসার লজিকও স্পষ্টভাবে প্রকাশ করে।

## অ্যানালজি: "শহরের নকশা ও নিয়ম"

ধরা যাক, আপনি একটি নতুন শহর বানাচ্ছেন। সেখানে রাস্তা, স্কুল, হাসপাতাল, বাজার—সবকিছু পরিকল্পনা করে, নিয়ম-কানুন ঠিক করে, তারপর নির্মাণ শুরু করেন। যদি শুধু বিল্ডিং বানান, কিন্তু শহরের নিয়ম না মানেন, তাহলে বিশৃঙ্খলা হবে। DDD-ও ঠিক এমন—প্রথমে ডোমেইন বুঝুন, তারপর কোড লিখুন।

## বিস্তারিত আলোচনা

### Domain-driven Design (DDD) কী?
- DDD হলো সফটওয়্যার ডিজাইনের একটি পদ্ধতি, যেখানে ব্যবসার ডোমেইন (নিয়ম, নিয়মাবলী, সমস্যা) আগে বোঝা হয়
- কোডের স্ট্রাকচার, ক্লাস, টাইপ, ফাংশন—সবকিছু ডোমেইন-ভিত্তিক হয়
- Communication gap কমে, কারণ কোডে ব্যবসার ভাষা (ubiquitous language) ব্যবহার হয়

### DDD-এর মূল ধারণা
- **Entity:** ব্যবসার গুরুত্বপূর্ণ অবজেক্ট, যার নিজস্ব পরিচয় আছে (ID)
- **Value Object:** অবজেক্ট যার পরিচয় নেই, শুধু value আছে (যেমন: Address)
- **Aggregate:** একাধিক Entity ও Value Object-এর গ্রুপ, যা একসাথে ম্যানেজ হয়
- **Repository:** ডেটা স্টোরেজের জন্য abstraction
- **Service:** ব্যবসার লজিক, যা Entity বা Value Object নয়
- **Ubiquitous Language:** কোডে ও আলোচনায় একই ভাষা ব্যবহার

### TypeScript-এ DDD
- টাইপ, ইন্টারফেস, ক্লাস দিয়ে Entity, Value Object, Aggregate তৈরি করা যায়
- Repository ও Service abstraction সহজে ইমপ্লিমেন্ট করা যায়
- টাইপ সেফটি ও ডোমেইন লজিক একসাথে ম্যানেজ করা যায়

### উদাহরণ
```typescript
// Entity
interface User {
  id: string;
  name: string;
  address: Address;
}

// Value Object
interface Address {
  street: string;
  city: string;
  zip: string;
}

// Aggregate
interface Order {
  id: string;
  user: User;
  items: OrderItem[];
}

// Repository
interface UserRepository {
  findById(id: string): User | null;
  save(user: User): void;
}

// Service
class OrderService {
  createOrder(user: User, items: OrderItem[]): Order {
    // ...business logic
  }
}
```

## বুলেট পয়েন্টস
- DDD-তে ব্যবসার নিয়ম-কানুন আগে বুঝুন
- Entity, Value Object, Aggregate, Repository, Service—সবকিছু টাইপ/ইন্টারফেস/ক্লাস দিয়ে মডেল করুন
- Ubiquitous Language ব্যবহার করুন—কোডে ও আলোচনায় একই টার্ম
- TypeScript-এ টাইপ সেফটি দিয়ে ডোমেইন লজিক enforce করুন
- বড় প্রজেক্টে DDD কোডবেসকে maintainable ও scalable করে তোলে

## প্র্যাকটিকাল এক্সারসাইজ

1. **ডোমেইন মডেলিং করুন:**
   - আপনার ব্যবসার জন্য Entity, Value Object, Aggregate টাইপ/ইন্টারফেস লিখুন
   - Repository ও Service abstraction তৈরি করুন

2. **Ubiquitous Language ব্যবহার করুন:**
   - কোডে ও ডকুমেন্টেশনে একই টার্ম ব্যবহার করুন

3. **রিফ্যাক্টরিং:**
   - একটি ফিচারকে DDD প্যাটার্নে রিফ্যাক্টর করুন

## সম্পর্কিত পাঠ
- [Contract-first API ডিজাইন](/typescript/api-contracts)
- [মাইক্রোসার্ভিসে টাইপ-সেফ gRPC ও ইভেন্ট-ড্রিভেন সিস্টেম](/typescript/microservices)
- [Type-safe Builders ও Fluent API ডিজাইন](/typescript/fluent-api)

---

**শেষ কথা:**
TypeScript-এ DDD ব্যবহার করলে কোড শুধু ফিচার নয়, ব্যবসার লজিকও স্পষ্টভাবে প্রকাশ পায়। বড় ও জটিল প্রজেক্টে maintainability, scalability, এবং communication অনেক সহজ হয়। ডোমেইন বুঝে, পরিকল্পনা করে, তারপর কোড লিখুন—এটাই DDD-এর মূল শিক্ষা।
