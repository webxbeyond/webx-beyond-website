---
title: Authentication বনাম Authorization
icon: solar:alt-arrow-right-bold-duotone
---

এই পাঠে আমরা Authentication (নির্ধারণ—who are you?) ও Authorization (অনুমতি—what can you do?) এর পার্থক্য এবং প্রতিটি স্তরে বাস্তবপন্থা, আর্কিটেকচার, ও নিরাপত্তার টিপস দেবো। কভার করা হবে: লগইন প্যাটার্ন, পাসওয়ার্ড হ্যাশিং, MFA, OAuth2/OpenID Connect, JWT এবং সেশন ম্যানেজমেন্ট, RBAC/ABAC, API authentication (HMAC, API key), সিকিউরিটি আক্রমণ প্রতিকার (CSRF, session fixation), secrets management ও অপারেশনাল কার্যক্রম (rotation, auditing, monitoring)। লক্ষ্য: আপনি একটি প্রডাকশন‑গ্রেড auth সিস্টেম ডিজাইন ও অপারেট করতে পারবেন বা একটি identity provider reuse করার সিদ্ধান্ত নিতে পারবেন।

## চেকলিস্ট (আপনার অনুরোধ অনুযায়ী)

- Authentication vs Authorization স্পষ্টভাবে ব্যাখ্যা করা
- Password storage ও hashing best practices
- MFA/2FA প্যাটার্ন ও UX টিপস
- OAuth2 ও OpenID Connect বাস্তব ব্যবহার ও ফ্লো গাইড
- JWT ব্যবহার, ঝুঁকি ও mitigation (revocation, rotation)
- Session management, cookie flags, CSRF, session fixation
- API authentication: API keys, HMAC, signed requests
- RBAC vs ABAC vs PBAC ও delegation patterns
- Secrets management, rotation ও auditing
- Scaling/availability considerations এবং decision flow

---

## ১) Authentication বনাম Authorization — সোজা পার্থক্য

- Authentication: ব্যবহারকারী বা সার্ভিসের পরিচয় নিশ্চিত করা (Who are you?)
- Authorization: সেই পরিচিত ব্যক্তি/সার্ভিস কী কি কার্য করতে পারবে বলে নির্ধারণ করা (What are you allowed to do?)

রূপক: Authentication হলো প্রবেশদ্বারে পরিচয় দেখানো (ID চেক); Authorization হলো টিকিট দেখিয়ে কোন রুমে ঢুকতে পারবেন কি না নির্ধারণ করা।

ওপেনিং নীতি: সব authentication আজীবন নয়—সেশন, কিংবদন্তি ও credential lifecycle‑এর কথা মাথায় রাখুন।

## ২) Password storage ও credentials নিরাপত্তা

- কখনো plain text নয়। পাসওয়ার্ড স্টোর করলে strong hashing algorithm ব্যবহার করুন: Argon2id, bcrypt, বা scrypt
- Hashing parameters (work factor, memory) টিউন করুন: CPU এবং memory trade‑offs আছে; Argon2 মডার্ন পছন্দ
- Salt: প্রতিটি password‑এ unique random salt যোগ করুন
- Pepper: optional — সার্ভার‑side secret added to hashes stored separately (নোড‑level secret)
- Rate limiting ও account lockouts: brute force protection
- Password policies: length & passphrase emphasis, not just complexity; prefer length over weird symbols requirement

Example checklist for password flow:
- On signup: generate salt, compute Argon2id(hash), store (salt, hash, Argon2 params)
- On login: compute hash with stored salt & params, compare constant time

## ৩) Multi‑Factor Authentication (MFA)

- MFA types: SMS OTP (convenient but weaker), TOTP (Authenticator apps), Push MFA, U2F/WebAuthn (hardware keys)
- Recommendation: support WebAuthn/FIDO2 for highest security; TOTP as fallback; avoid SMS for high‑security flows
- UX: progressive disclosure — require MFA for sensitive operations (payments, recovery, admin)
- Recovery: provide secure recovery flows (backup codes, hardware key registration), avoid insecure resets

## ৪) Session management ও cookie security

- Two approaches: stateful server sessions (session store) vs stateless tokens (JWT)
- Cookies: set Secure, HttpOnly, SameSite=strict/lax appropriately; avoid storing tokens in localStorage for browsers
- Session fixation mitigation: regenerate session id on privilege change (e.g., login)
- Idle & absolute session timeouts; sliding expiration tradeoffs
- Logout: ensure server‑side session invalidation or token revocation

Cookie flags summary:
- HttpOnly: prevent JS access
- Secure: only over HTTPS
- SameSite: mitigate CSRF (Lax good default, Strict if app supports)

## ৫) CSRF, XSS, session fixation ও mitigations

- CSRF: use SameSite cookies, anti‑CSRF tokens (double submit cookie or server‑side stored token), and verify Origin/Referer for sensitive endpoints
- XSS: sanitize user input, Content Security Policy (CSP), HttpOnly cookies
- Session fixation: always issue new session id after authentication

## ৬) Token patterns: JWT, opaque tokens, refresh tokens

- JWT (JSON Web Token): self‑contained token with claims, can be statelessly verified with signature
  - Advantages: easy to scale (no server session), carries metadata
  - Risks: revocation hard if purely stateless, large tokens, signature algorithm misuse
- Opaque tokens: random string referencing server‑side store — easy to revoke
- Best practice: use short‑lived access tokens + long‑lived refresh tokens (refresh tokens stored securely; rotate on use)
- Token rotation: issue new refresh token on each refresh and revoke old one to mitigate replay
- Introspection endpoint (OAuth2) for resource servers to validate opaque tokens

Security tips for JWT:
- Validate signature and claims (iss, aud, exp, nbf)
- Use asymmetric signing (RS256/ES256) for distributed verification; protect private keys
- Avoid including sensitive data in token payloads

## ৭) OAuth2 ও OpenID Connect (OIDC) — practical guide

- OAuth2: authorization framework for delegated access. OIDC extends OAuth2 to provide authentication (identity layer)
- Common flows:
  - Authorization Code Flow (with PKCE for public clients): recommended for web & mobile
  - Client Credentials Flow: machine‑to‑machine
  - Implicit Flow: deprecated
  - Resource Owner Password Credentials: discouraged

- PKCE: required for native/mobile apps — prevents interception of auth code
- Scopes & consent: use minimal scopes, explain consent to users
- Claims mapping: map identity provider claims to your internal user model

When to use an IdP vs build your own:
- Use managed IdPs (Auth0, Okta, Keycloak, AWS Cognito) unless you have strong reason to build—security and compliance are non‑trivial

## ৮) Authorization models: RBAC, ABAC, PBAC

- RBAC (Role‑Based Access Control): assign roles to users, permissions to roles — simple and easy to reason
- ABAC (Attribute‑Based Access Control): policies based on attributes (user, resource, environment) — expressive
- PBAC (Policy‑Based Access Control) / XACML: centralized policy service (PDP/PEP) for complex decisions

Delegation patterns:
- OAuth2 scopes vs full RBAC: use scopes for delegated access to APIs; internal authorization may use RBAC/ABAC
- Principle of least privilege: grant minimal rights by default

## ৯) API authentication: API keys, HMAC, signed requests

- API keys: simple but bearer tokens—protect and rotate regularly
- HMAC / signed requests (AWS‑style): request signing including timestamp and canonicalized payload — resists replay and tampering
- Mutual TLS (mTLS): strong machine authentication using client certificates

Choose pattern by threat model:
- Public third‑party clients → OAuth2 with scopes
- Internal services → mTLS or mutual authentication + short‑lived certificates
- Third‑party server‑to‑server → client credentials flow + signed requests

## ১০) Secrets management ও key rotation

- Never store secrets in version control. Use dedicated secrets manager (HashiCorp Vault, AWS Secrets Manager, Azure Key Vault)
- Automate rotation of keys/credentials and keep audit logs
- Use short‑lived credentials / dynamic secrets where possible (Vault leasing)
- Protect private keys of signing certificates (HSM or cloud KMS)

## ১১) Auditing, logging ও compliance

- Log authentication events: login success/failure, MFA events, token issuance/revocation, privileged actions
- Protect logs (PII) and ensure retention policies meet compliance
- Monitor abnormal patterns: login spikes, geo‑anomalies, impossible travel

## ১২) Scaling: central auth service vs distributed tokens

- Centralized identity service (IdP) with short lived tokens scales well; resource servers validate tokens locally (JWT) or via introspection
- Stateful sessions require session stores (Redis) — scale with cluster and sticky sessions if needed
- Caching verification keys (JWKS) to avoid repeated network calls

Design tradeoffs:
- Stateless JWTs reduce central load but complicate revocation
- Stateful tokens simplify revocation but add operational complexity

## ১৩) Testing & threat modelling

- Threat model: enumerate assets, actors, attack vectors (credential stuffing, token theft, CSRF)
- Automated tests: unit tests for auth logic, integration tests against IdP, pen testing
- Security testing: fuzzing endpoints, brute force simulation, check for open redirect, improper token validation

## ১৪) Monitoring & SLOs

Key metrics:
- auth_success_rate, auth_latency_seconds
- mfa_enrollment_rate, mfa_challenge_failures
- token_issue_rate, token_revocation_rate
- failed_login_rate (per IP, per user)

SLO examples:
- 99.9% auth request latency < 500ms
- failed_login_rate under threshold; alert on spikes

## ১৫) Operational runbooks

- Compromised credential response: force password reset, revoke tokens, invalidate sessions, notify users
- Key compromise: rotate signing keys, publish new JWKS, support key rollover for verification
- IdP outage: have fallback authentication (cached tokens, read‑only maintenance mode) and documented failover steps

## ১৬) Privacy & legal considerations

- Minimize stored PII; password reset flows must avoid leaking sensitive info
- Comply with regulations (GDPR, CCPA) on data subject rights and breach notification

## ১৭) Decision flow — build vs reuse

- Use managed IdP unless you need full control/compliance reasons
- Build only when:
  - You need custom credential semantics or offline auth
  - You have the team and processes for secure key management and audits
- Prefer open standards (OAuth2, OIDC, SAML) to reduce integration friction

---

আপনি চাইলে আমি এই পাতায় একটি রানেবল Node.js + Express উদাহরণ যোগ করে দিবো: (A) OAuth2 Authorization Code flow with PKCE + OIDC login and session handling, (B) JWT access + rotating refresh tokens example with tests, অথবা (C) RBAC policy example (OPA/Rego) integrated with an API gateway — কোনটা আগে যোগ করব?
