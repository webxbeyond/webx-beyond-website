---
title: রাস্ট চিটশিট
description: রাস্ট (Rust) হলো একটি আধুনিক সিস্টেম প্রোগ্রামিং ভাষা যা নিরাপত্তা, গতি, এবং সমান্তরালতার (concurrency) উপর জোর দেয়। এই চিটশিটে রাস্টের সব মৌলিক থেকে উন্নত ধারণা, সিনট্যাক্স, এবং ব্যবহার বিস্তারিতভাবে কভার করা হয়েছে।
icon: simple-icons:rust
---

## ১. রাস্ট পরিচিতি

### ১.১ মৌলিক ধারণা
- **মেমরি নিরাপত্তা**: ম্যানুয়াল মেমরি ম্যানেজমেন্ট ছাড়াই।
- **ওনারশিপ**: মেমরি লিক এবং ডেটা রেস প্রতিরোধ।
- **কার্গো**: রাস্টের প্যাকেজ ম্যানেজার।

### ১.২ ইনস্টলেশন ও সেটআপ
- **ইনস্টলেশন**:
  ```bash
  curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
  ```
- **চেক করুন**: 
  ```bash
  rustc --version
  cargo --version
  ```
- **নতুন প্রজেক্ট**:
  ```bash
  cargo new myproject
  cd myproject
  cargo run
  ```

---

## ২. রাস্ট সিনট্যাক্স

### ২.১ হ্যালো ওয়ার্ল্ড
`src/main.rs`:
```rust
fn main() {
    println!("হ্যালো, রাস্ট!");
}
```

- **কম্পাইল ও রান**:
  ```bash
  rustc main.rs
  ./main
  ```
  অথবা `cargo run`।

---

### ২.২ ভেরিয়েবল
- **Immutable (ডিফল্ট)**:
```rust
let x = 5;
```
- **Mutable**:
```rust
let mut y = 10;
y = 15;
```
- **কনস্ট্যান্ট**:
```rust
const MAX: i32 = 100;
```

---

### ২.৩ ডেটা টাইপ
| টাইপ          | বর্ণনা                                      | উদাহরণ                          |
|---------------|---------------------------------------------|---------------------------------|
| `i32`, `u32`  | ৩২-বিট সংখ্যা (signed/unsigned)।           | `let x: i32 = -10;`            |
| `f64`         | ৬৪-বিট ফ্লোট।                              | `let y: f64 = 3.14;`           |
| `bool`        | সত্য/মিথ্যা।                               | `let z: bool = true;`          |
| `char`        | একক ইউনিকোড অক্ষর।                         | `let c: char = 'র';`           |
| `&str`        | স্ট্রিং স্লাইস।                             | `let s: &str = "রাস্ট";`       |
| `String`      | মিউটেবল স্ট্রিং।                            | `let s = String::from("রাস্ট");` |

---

### ২.৪ টাইপ ইনফারেন্স
```rust
let x = 42; // স্বয়ংক্রিয়ভাবে i32
let y: u32 = 42; // স্পষ্ট টাইপ
```

---

## ৩. ওনারশিপ এবং বোরোইং

### ৩.১ ওনারশিপ
- প্রতিটি মানের একটি মালিক থাকে।
```rust
let s1 = String::from("হ্যালো");
let s2 = s1; // s1 এর মালিকানা s2-এ চলে যায়
// println!("{}", s1); // এরর: s1 ব্যবহারযোগ্য নয়
```

---

### ৩.২ বোরোইং
- **Immutable Reference**:
```rust
let s = String::from("হ্যালো");
let r = &s;
println!("{}", r); // হ্যালো
```
- **Mutable Reference**:
```rust
let mut s = String::from("হ্যালো");
let r = &mut s;
r.push_str(", রাস্ট!");
println!("{}", r); // হ্যালো, রাস্ট!
```

- **নিয়ম**:
  - একসাথে একটি মিউটেবল রেফারেন্স বা একাধিক ইমিউটেবল রেফারেন্স।
  - কোনো রেফারেন্স থাকলে মালিকানা সরানো যায় না।

---

### ৩.৩ ক্লোনিং
```rust
let s1 = String::from("হ্যালো");
let s2 = s1.clone(); // গভীর কপি
println!("s1: {}, s2: {}", s1, s2);
```

---

## ৪. ফাংশন

### ৪.১ ফাংশন সংজ্ঞা
```rust
fn add(a: i32, b: i32) -> i32 {
    a + b // সেমিকোলন ছাড়া = রিটার্ন
}

fn main() {
    let sum = add(5, 3);
    println!("যোগফল: {}", sum);
}
```

---

### ৪.২ ক্লোজার
```rust
let double = |x: i32| x * 2;
println!("দ্বিগুণ: {}", double(5));
```

---

## ৫. কন্ট্রোল ফ্লো

### ৫.১ শর্ত
```rust
let age = 20;
if age >= 18 {
    println!("প্রাপ্তবয়স্ক");
} else if age > 0 {
    println!("শিশু");
} else {
    println!("অবৈধ");
}
```

- **If এক্সপ্রেশন**:
```rust
let status = if age >= 18 { "প্রাপ্তবয়স্ক" } else { "শিশু" };
```

---

### ৫.২ লুপ
| লুপ          | বর্ণনা                                      | উদাহরণ                          |
|--------------|---------------------------------------------|---------------------------------|
| `loop`       | অসীম লুপ।                                  | `loop { println!("চলছে"); break; }` |
| `while`      | শর্ত সত্য হলে।                             | `while x < 5 { x += 1; }`      |
| `for`        | রেঞ্জ/ইটারেটরের জন্য।                       | `for i in 1..4 { println!("{}", i); }` |

**উদাহরণ:**
```rust
for i in 0..3 {
    println!("গণনা: {}", i);
}
```

---

## ৬. ডেটা স্ট্রাকচার

### ৬.১ টাপল
```rust
let t = (1, "হ্যালো", 3.14);
println!("প্রথম: {}", t.0);
let (x, y, z) = t; // ডিস্ট্রাকচারিং
```

---

### ৬.২ অ্যারে
```rust
let a = [1, 2, 3, 4];
println!("প্রথম: {}", a[0]);
```

---

### ৬.৩ ভেক্টর
```rust
let mut v = Vec::new();
v.push(1);
v.push(2);
println!("ভেক্টর: {:?}", v);

let v2 = vec![1, 2, 3];
```

---

### ৬.৪ স্ট্রাক্ট
```rust
struct User {
    name: String,
    age: u32,
    active: bool,
}

let user = User {
    name: String::from("রহিম"),
    age: 25,
    active: true,
};

println!("নাম: {}", user.name);
```

- **ইমপ্লিমেন্টেশন**:
```rust
impl User {
    fn greet(&self) -> String {
        format!("হ্যালো, {}!", self.name)
    }
}

let greeting = user.greet();
```

---

### ৬.৫ এনাম
```rust
enum Direction {
    North,
    South,
    East,
    West,
}

let dir = Direction::North;
```

- **ডেটা সহ এনাম**:
```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
}

let msg = Message::Write(String::from("হ্যালো"));
```

---

## ৭. ম্যাচ এবং প্যাটার্ন ম্যাচিং
```rust
enum Coin {
    Penny,
    Nickel,
}

let coin = Coin::Penny;
match coin {
    Coin::Penny => println!("১ সেন্ট"),
    Coin::Nickel => println!("৫ সেন্ট"),
}
```

- **অপশন**:
```rust
let x: Option<i32> = Some(5);
match x {
    Some(val) => println!("মান: {}", val),
    None => println!("কিছু নেই"),
}
```

---

## ৮. এরর হ্যান্ডলিং

### ৮.১ Option
```rust
let num = Some(10);
let result = num.unwrap_or(0); // ১০, None হলে ০
```

---

### ৮.২ Result
```rust
fn divide(a: i32, b: i32) -> Result<i32, String> {
    if b == 0 {
        Err(String::from("শূন্য দিয়ে ভাগ করা যায় না"))
    } else {
        Ok(a / b)
    }
}

match divide(10, 2) {
    Ok(result) => println!("ফলাফল: {}", result),
    Err(e) => println!("এরর: {}", e),
}
```

- **? অপারেটর**:
```rust
fn try_divide() -> Result<i32, String> {
    let result = divide(10, 2)?;
    Ok(result)
}
```

---

## ৯. ট্রেইট (Traits)

### ৯.১ ট্রেইট সংজ্ঞা
```rust
trait Printable {
    fn print(&self) -> String;
}

struct Book {
    title: String,
}

impl Printable for Book {
    fn print(&self) -> String {
        format!("বই: {}", self.title)
    }
}

let book = Book { title: String::from("রাস্ট গাইড") };
println!("{}", book.print());
```

---

### ৯.২ ডিফল্ট ইমপ্লিমেন্টেশন
```rust
trait Describable {
    fn describe(&self) -> String {
        String::from("অজানা")
    }
}

impl Describable for Book {}
```

---

## ১০. জেনেরিক্স
```rust
fn largest<T: PartialOrd>(a: T, b: T) -> T {
    if a > b { a } else { b }
}

let max = largest(5, 10); // ১০
```

---

## ১১. সমান্তরালতা (Concurrency)

### ১১.১ থ্রেড
```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..5 {
            println!("থ্রেড: {}", i);
            thread::sleep(Duration::from_millis(100));
        }
    });

    for i in 1..3 {
        println!("মেইন: {}", i);
        thread::sleep(Duration::from_millis(100));
    }

    handle.join().unwrap();
}
```

---

### ১১.২ চ্যানেল
```rust
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        tx.send(String::from("হ্যালো")).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("পাওয়া গেছে: {}", received);
}
```

---

### ১১.৩ মিউটেক্স
```rust
use std::sync::{Mutex, Arc};

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..3 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("গণনা: {}", *counter.lock().unwrap());
}
```

---

## ১২. ম্যাক্রো
```rust
macro_rules! say_hello {
    ($name:expr) => {
        println!("হ্যালো, {}!", $name);
    };
}

fn main() {
    say_hello!("রহিম");
}
```

---

## ১৩. মডিউল
`src/lib.rs`:
```rust
pub mod utils {
    pub fn add(a: i32, b: i32) -> i32 {
        a + b
    }
}
```

`src/main.rs`:
```rust
use crate::utils::add;

fn main() {
    println!("যোগফল: {}", add(5, 3));
}
```

---

## ১৪. টেস্টিং
`src/lib.rs`:
```rust
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(2, 3), 5);
    }
}
```

- **চালানো**: `cargo test`

---

## ১৫. উদাহরণ: একটি সম্পূর্ণ প্রোগ্রাম
`src/main.rs`:
```rust
use std::collections::HashMap;

#[derive(Debug)]
struct Student {
    name: String,
    grade: u32,
}

impl Student {
    fn new(name: &str, grade: u32) -> Self {
        Student {
            name: String::from(name),
            grade,
        }
    }
}

fn main() {
    let mut students: HashMap<String, Student> = HashMap::new();

    students.insert(
        String::from("রহিম"),
        Student::new("রহিম", 85),
    );
    students.insert(
        String::from("করিম"),
        Student::new("করিম", 90),
    );

    for (key, student) in &students {
        println!("{}: গ্রেড = {}", key, student.grade);
    }

    let rahim = students.get("রহিম").unwrap();
    println!("রহিমের তথ্য: {:?}", rahim);
}
```

- **চালানো**: `cargo run`

---

## ১৬. রাস্ট টিপস
- **`unwrap()`**: দ্রুত প্রোটোটাইপিং-এ ব্যবহার করুন, প্রোডাকশনে এড়িয়ে চলুন।
- **`cargo fmt`**: কোড ফরম্যাট।
- **`cargo clippy`**: লিন্টিং এবং সাজেশন।