---
title: "Memoization: React.memo, useMemo, useCallback"
icon: mdi:memory
description: React-এ memoization কী, কেন দরকার এবং কিভাবে React.memo, useMemo ও useCallback ব্যবহার করে অপ্রয়োজনীয় রেন্ডার কমানো যায় — TypeScript উদাহরণসহ
keywords:
  - memoization
  - react.memo
  - useMemo
  - useCallback
  - performance
---

আমি যা করব — সংক্ষিপ্ত পরিকল্পনা:

- memoization ধারণা সহজভাবে বুঝিয়ে দেব
- `React.memo`, `useMemo`, `useCallback` কী করে এবং কখন ব্যবহার করবেন দেখাবো
- TypeScript-এ বাস্তব উদাহরণ দেবো (ProductList, Button, expensive compute)
- সাধারণ ভুল, stale closure, dependency array সমস্যা ও কিভাবে পরিমাপ করবেন তা বলব
- practical exercise দেবো যাতে আপনি নিজে মাপেন ও অপটিমাইজ করেন

চেকলিস্ট (আপনার অনুরোধ থেকে বের করা):
- [x] নতুন MDX ফাইল frontmatter সহ (`title`, `icon`, `description`, `keywords`)
- [x] পুরো আর্টিকেল বাংলা ভাষায় ও beginner-friendly
- [x] কঠিন ধারণার জন্য সহজ analogy আছে
- [x] React + TypeScript উদাহরণ এবং practical exercise দেয়া হয়েছে
- [x] index মডিউলগুলোর পুনরাবৃত্তি এড়ানো হয়েছে; ফোকাস memoization ও পারফরম্যান্স

---

## প্রাথমিক ধারণা: Memoization কি এবং কেন?

Memoization হলো একটি কৌশল যেখানে কোনো ফাংশনের ফলাফল ধরে রাখা হয় (cache) যাতে একই ইনপুট দিলে ভবিষ্যতে আবার গণনা না করে দ্রুত পূর্বের ফল ব্যবহার করা যায়।

সহজ analogy: ধরুন আপনি কোন দোকানের বাড়ির রাস্তা বারবার জিজ্ঞেস করছেন — প্রথমবার লোকটা পুরো ম্যাপ বুঝিয়ে বলল, পরবর্তীতে যদি ঠিক একই প্রশ্ন করেন, সে আবার পুরো ম্যাপ করতেও হবে না; সে আগের উত্তরই জিজ্ঞাসার মুহূর্তে ব্যবহার করে। এটিই memoization।

React-এ memoization দরকার হয় যখন:
- কোনো expensive (দামি) গণনা অনেকবার হচ্ছে
- কম্পোনেন্টগুলো অনিচ্ছাকৃতভাবে বারবার রেন্ডার হচ্ছে কারণ parent থেকে প্রতিবার নতুন props যায়

কিন্তু সবসময় memoization লাগানো উচিত নয় — অপ্রয়োজনীয় memoization কোড জটিল করে, এবং cache-management নিজেই কিছু কস্ট বাড়ায়। তাই meten before optimizing।

---

## React.memo — presentational component memoization

`React.memo` একটি higher-order component যা সাধারণত presentational (pure) component-এর জন্য ব্যবহৃত হয়। এটি shallow compare করে props অপরিবর্তিত থাকলে পুনরায় রেন্ডার করেনা।

TypeScript উদাহরণ:

```tsx
import React from 'react'

type Props = { title: string; onClick?: () => void }

function RawButton({ title, onClick }: Props) {
  console.log('RawButton render', title)
  return <button onClick={onClick}>{title}</button>
}

export const Button = React.memo(RawButton)
```

ব্যবহার:
- যদি parent বারবার রেন্ডার করে কিন্তু `title` ও `onClick` একই থাকে, `Button` রেন্ডার হবে না

সীমাবদ্ধতা:
- React.memo shallow compare করে — object/array/function props নতুন identity পেলে memo fail করবে (উদাহরণ: `onClick={() => doSomething()}` প্রতি রেন্ডারে নতুন ফাংশন)

---

## useCallback — ফাংশন identity ধরে রাখা

`useCallback` একটি function reference memoizer। এটি নির্দিষ্ট dependency arrayের উপর ভিত্তি করে একই ফাংশন reference ফেরত দেয়। সাধারণত React.memo-এর সাথে useCallback ব্যবহার করা হয় যাতে child components-এ props হিসেবে পাঠানো function তখনই পরিবর্তন হয় যখন দরকার।

উদাহরণ:

```tsx
import React, { useCallback, useState } from 'react'

function Parent(){
  const [count, setCount] = useState(0)

  const handleClick = useCallback(() => {
    console.log('clicked')
  }, [])

  return (
    <div>
      <button onClick={() => setCount(c => c + 1)}>inc {count}</button>
      <Button title="Save" onClick={handleClick} />
    </div>
  )
}
```

এখানে `handleClick` একই reference থাকবে যতক্ষণ dependency (এখানে []) বদলায় না। ফলে `Button`-এ পাঠানো `onClick` props-এ identity পরিবর্তন হবে না এবং React.memo কাজ করবে।

নোট: useCallback নিজেই একটু cost আছে — ছোট ফাংশনের জন্য useCallback ব্যবহার করলে বেশি ক্ষতি হতে পারে।

---

## useMemo — expensive value memoization

`useMemo` নির্দিষ্ট value (যেমন expensive computation, derived data) cache করে দেয়। এটি computation পুনরাবৃত্তি রোধ করে যতক্ষণ dependencies অপরিবর্তিত থাকে।

উদাহরণ (expensive calculation):

```tsx
import React, { useMemo } from 'react'

function fib(n: number): number {
  if (n < 2) return n
  return fib(n - 1) + fib(n - 2)
}

export function FibDemo({ n }: { n: number }){
  const value = useMemo(() => fib(n), [n])
  return <div>Fib({n}) = {value}</div>
}
```

এখানে fib computation কেবল তখনই হবে যখন `n` বদলায়।

সতর্কতা:
- useMemo শুধুমাত্র optimization helper — এটি functional correctness-এর অংশ নয়
- যদি computation cheap হয়, useMemo ব্যবহারের ব্যয় বেশি হতেই পারে

---

## Common pitfalls ও anti-patterns

1. Overuse of useMemo/useCallback:
   - ছোট/cheap কাজগুলোতে memoization করলে RAM ও CPU কস্ট বেশি হতে পারে
2. Wrong dependency arrays:
   - missed dependency → stale closure (ফাংশন পুরনো ভ্যালু ধরবে)
   - extra dependencies → unnecessary recompute
3. Objects/arrays inline as props:
   - `data={[1,2,3]}` প্রত্যেক রেন্ডারে নতুন array তৈরী করে। এই ক্ষেত্রে useMemo দিয়ে array-cache করুন
4. Premature memoization without measurement:
   - আগে profile করে দেখুন কোথায় বটলনেক

Stale closure example:

```tsx
function Counter(){
  const [count, setCount] = useState(0)
  const log = useCallback(() => {
    console.log('count', count)
  }, []) // ❌ count missing → stale closure
}
```

ঠিক করার জন্য dependency array-এ `count` যোগ করতে হবে অথবা functional update ব্যবহার করতে হবে।

---

## Measuring effectiveness — কিভাবে জানবেন memoization কাজ করেছে?

- React DevTools Profiler: render count ও render time দেখুন
- console logs: render lifecycle-এ log করে before/after তুলনা
- benchmark: critical interaction-এর আগে/পর profile রাখুন

প্রতিটি optimization-এর পরে measure করুন — যদি সুবিধা না থাকে, revert করুন।

---

## Practical example: ProductList optimization (TypeScript)

সাবধানে একটি ছোট উদাহরণ দেখি — ProductList যেখানে প্রতিটি ProductCard re-render হয় যেটা avoid করতে চাই

```tsx
// ProductCard.tsx
import React from 'react'

type Product = { id: string; name: string; price: number }

export const ProductCard = React.memo(function ProductCard({ p, onAdd }:
  { p: Product; onAdd: (id: string) => void }
){
  console.log('ProductCard render', p.id)
  return (
    <article>
      <h4>{p.name}</h4>
      <div>{p.price}</div>
      <button onClick={() => onAdd(p.id)}>Add</button>
    </article>
  )
})

// ProductList.tsx
import React, { useCallback } from 'react'

export function ProductList({ products }:{ products: Product[] }){
  const handleAdd = useCallback((id: string) => {
    // add to cart
  }, [])

  return (
    <div>
      {products.map(p => (
        <ProductCard key={p.id} p={p} onAdd={handleAdd} />
      ))}
    </div>
  )
}
```

এখানে `ProductCard` React.memo দিয়ে মোড়ানো আছে এবং `handleAdd` useCallback দিয়ে stable রাখা হয়েছে — ফলে ProductList parent re-render করলেও ProductCard পুনরায় রেন্ডার হবে না যদি `products` identity পরিবর্তন না করে।

Tip: যদি `products` প্রতি রেন্ডারে নতুন array হয় (even same items), consider memoizing products or using state/reference that avoids new identity.

---

## When not to use memoization

- ছোট ও cheap কাজ যেখানে render cheap
- code complexity বা bugs বাড়ছে
- measurement দেখায় negligible benefit

সর্বদা measure করুন। Optimization is a trade-off.

---

## Practical exercise — Measure & Optimize Product List

লক্ষ্য: একটি ছোট অ্যাপ তৈরি/ব্যবহার করে ProductList-এর unnecessary render কমানো ও timing রিপোর্ট করা।

স্টেপস:
1. তৈরি করুন একটি ছোট Vite React+TS অ্যাপ যেখানে 100টি product রেন্ডার হয় (simple objects).
2. প্রথমে Profiler চালিয়ে দেখুন product card কতবার রেন্ডার হচ্ছে (before)
3. Apply fixes step-by-step:
   - Wrap ProductCard with React.memo
   - Memoize event handlers with useCallback
   - Ensure products array identity stable (useState / useMemo)
4. প্রত্যেক পরিবর্তনের পরে Profiler-run করে before/after তুলনা করুন

Exercise checklist:
- [ ] Before profile (render counts & timings) নেয়া হয়েছে
- [ ] React.memo প্রয়োগ করা হয়েছে যেখানে উপযুক্ত
- [ ] useCallback/useMemo প্রয়োগ করে identity issues সমাধান করা হয়েছে
- [ ] After profile তুলনা করা হয়েছে এবং ফলাফল নথিভুক্ত করা হয়েছে

---

## সংক্ষিপ্ত টিপস (Quick rules)

- Measure first — তারপর optimize
- Use React.memo for pure presentational components
- Use useCallback/useMemo sparingly — cost vs benefit চিন্তা করে
- Beware of stale closures — dependency arrays ঠিক রাখুন
- Keep code readable; document why a memoization আছে

---

## উপসংহার

Memoization শক্তিশালি টুল, কিন্তু ভুলভাবে ব্যবহার করলে সমস্যা বাড়ায়। React.memo, useMemo ও useCallback-কে toolbox হিসেবে রাখুন — দরকারি জায়গায় সতর্কতার সঙ্গে ব্যবহার করুন এবং প্রতিটি পরিবর্তনের পরে পরিমাপ করে সিদ্ধান্ত নিন।

আপনি চাইলে আমি একটি runnable Vite + React + TypeScript starter scaffold করে দিতে পারি যেখানে ProductList, Profiler-hooks এবং before/after benchmark আছে — বলুন কোন স্টার্টার চান (Vite বা Next.js)।

---
